# 会话跟踪

## Cookie

Cookie 是一小块可以嵌入 HTTP 请求和响应的数据。

当用户通过 HTTP 访问服务器时，服务器可以产生 Cookie 并将它作为响应头域的一部分返回给浏览器。浏览器在收到有 Cookie 的响应后，会把 Cookie 的内容以键值对（key/value）的形式写入到一个文本文件中。在用户再次访问服务器时（在符合 Cookie 的限制条件的前提下），会将 Cookie 数据作为请求头域的一部分发送给服务器。这样服务器就可以再次读取 Cookie 中存放的数据了。 

NOTE: 浏览器对 Cookie 的大小和数量会有一定的限制。

Cookie 的不足：

*   使用 Cookie 来传递信息时，随着 Cookie 数量和访问量的增加，它占用的网络带宽会很大。
*   保存在 Cookie 中的数据可以被访问，甚至被修改，安全性是一项很大的挑战。

## Session

Session 隐含了“面向连接”和“保持状态”这样两个含义。“面向连接”指的是通信双方在通信之前要先建立一个通信的渠道，如打电话，知道对方接了电话通信才能开始。“保持状态”则是指通信的一方方能够把一系列的消息关联起来，使得消息之间可以互相依赖。

Cookie 机制采用一种在客户端保持状态的解决方案。而 Session 机制采用的是一种在客户端与服务器之间保持状态的解决方案。由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以 Session 机制可能需要借助于 Cookie 机制来达到保存标识的目的。

使用 Cookie 来传递信息时，随着 Cookie 数量和访问量的增加，它占用的网络带宽会很大。所以对于大访问量希望用 Session，但是 Session 的弱点在于不容易在多台服务器之间共享。

## 实现会话跟踪

会话跟踪（session tracking）是一种在客户端和服务器之间保持状态的解决方案。简单地说，当一个客户在多个页面间切换时，服务器会保存该用户的信息。

会话跟踪的实现方式有以下4种：

*   使用持续 Cookies（Persistent Cookies）。

	例如，将会话信息记录在 HashMap 中，保存在服务器端，并用 sessionID 标识，然后把 sessionID 保存在名为JSESSIONID 的 Cookie 中。

	用户请求到达服务器后，先从 Cookie 中取出 sessionID，然后从 HashMap 中取出会话信息。这样就实现了会话追踪。

	但是如果用户关闭了 Cookie 的话，便无法利用 Cookie 来达到会话跟踪的功能。

*   重写包含额外参数的 URL（URL Rewriting）。

	URL 重写是利用 GET 方法，在 URL 的尾部添加一些额外的参数来达到会话跟踪的目的，服务器将这个标识符与它所存储的有关会话的数据关联起来，如下所示：

		http://host/path/file.html;jsessionid=1234

	使用 URL 重写的优点是 Cookie 被禁用或者根本不支持的情况下依旧能够工作，但也有很多缺点：

	*   必须对所有指向网站的 URL 进行编码。
	*   所有页面必须动态生成。
	*   不能使用预先记录下来的 URL 或者从其他网站链接进行访问。

*   建立含有数据的隐藏表单字段（Hidden Form Field）。

	利用 HTML 中的 hidden 属性，把客户端的信息以隐藏字段的方式发送给服务器。如下所示：

		<input type="hidden" name="userID" value="15"> 

	缺点在于只要用户直接查看 HTML 的源文件，Session 数据将会暴露无疑。

*   使用内置 Session 对象。

	内建 Session 对象基于 Cookie 或 URL 重写技术，融合了这两种技术的优点。当客户端允许使用 Cookie 时，内建 Session 对象使用 Cookie 进行会话跟踪，如果客户端禁用 Cookie，则选择使用 URL 重写。
	
	要实现 URL 重写，应该在 servlet 返回的所有 URL 上调用 response 的 `encodeURL(URL)` 方法。此方法仅当 cookie 被禁用时才会在 URL 中加入 session ID; 否则，它返回原始的 URL。